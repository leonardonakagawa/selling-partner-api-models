<?php

/**
 * TestHelper
 * PHP version 7.4
 *
 * @category Class
 * @package  {{invokerPackage}}\Test
 */
 {{common_header}}
 /**
  * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
  * https://openapi-generator.tech
  * Do not edit the class manually.
  */

namespace {{invokerPackage}}\Test;

use OpenAPI\Client\ObjectSerializer;
use ReflectionClass;
use ReflectionNamedType;
use ReflectionException;
use ReflectionMethod;
use Dotenv\Dotenv;

$dotenv = Dotenv::createImmutable('../../../sdk');
$dotenv->load();

/**
 * TestHelper
 * A helper class for testing OpenAPI responses.
 *
 * @category Class
 * @package  {{invokerPackage}}
 */
class TestHelper
{
    private static string $marketPlaceId = 'ATVPDKIKX0DER';

    /**
     * Maps the attributes of a given instance based on the expected response data.
     *
     * @param object $instance The instance to populate.
     * @param array $expectedData The expected response data as an associative array.
     * @return void
     */
    public static function mapAttributes(object $instance, array $expectedData): void
    {
        foreach ($instance::attributeMap() as $property => $jsonKey) {
            $setterMethod = $instance::setters()[$property] ?? null;
            $type = $instance::openAPITypes()[$property] ?? null;

            if (!isset($expectedData[$jsonKey])) {
                continue;
            }

            try {
                if (class_exists($type) && !is_a($type, \DateTime::class, true)) {
                    self::handleComplexType($instance, $setterMethod, $type, $expectedData[$jsonKey]);
                } elseif (str_ends_with($type, '[]')) {
                    $objectType = substr($type, 0, -strlen('[]'));
                    self::handleComplexType($instance, $setterMethod, $type, $expectedData[$jsonKey]);
                } else {
                    self::handleSimpleType($instance, $setterMethod, $type, $expectedData[$jsonKey]);
                }
            } catch (\Exception $e) {
                echo "Error deserializing property: $property. " . $e->getMessage() . "\n";
            }
        }
    }

    /**
     * Handles mapping for complex types (nested structures or arrays).
     *
     * @param object $instance The parent instance.
     * @param string|null $setterMethod The setter method for the property.
     * @param string $type The type of the property.
     * @param mixed $data The data to map.
     * @return void
     */
    private static function handleComplexType(object $instance, ?string $setterMethod, string $type, mixed $data): void
    {
        if (!is_array($data)) {
            $deserializedValue = ObjectSerializer::deserialize($data, $type);
            $instance->$setterMethod($deserializedValue);
            return;
        }

        if (array_keys($data) === range(0, count($data) - 1)) {
            // When $data is Array
            $nestedInstances = [];
            $listType = substr($type, 0, -2);
            foreach ($data as $itemData) {
                if (class_exists($listType) && method_exists($listType, 'openAPITypes')) {
                    $nestedNodeInstance = new $listType();
                    self::mapAttributes($nestedNodeInstance, $itemData);
                    $nestedInstances[] = $nestedNodeInstance;
                } else {
                    $deserializedValue = ObjectSerializer::deserialize($itemData, $listType);
                    $nestedInstances[] = $deserializedValue;
                }
            }
            $instance->$setterMethod($nestedInstances);
        } else {
            $nestedInstance = new $type();
            self::mapAttributes($nestedInstance, $data);
            $instance->$setterMethod($nestedInstance);
        }
    }

    /**
     * Handles mapping for simple types (primitives or DateTime).
     *
     * @param object $instance The instance to populate.
     * @param string|null $setterMethod The setter method for the property.
     * @param string $type The type of the property.
     * @param mixed $data The data to map.
     * @return void
     */
    private static function handleSimpleType(object $instance, ?string $setterMethod, string $type, mixed $data): void
    {
        $deserializedValue = ObjectSerializer::deserialize($data, $type);
        $instance->$setterMethod($deserializedValue);
    }

    /**
     * Converts a snake_case string to camelCase or PascalCase.
     *
     * @param string $snakeCase The input string in snake_case format.
     * @param bool $capitalizeFirst If true, returns PascalCase; if false, returns camelCase.
     * @return string The converted string in camelCase or PascalCase format.
     */
    private static function snakeToCamelCase(string $snakeCase, bool $capitalizeFirst = true): string
    {
        // Split the input string by underscores into an array of words
        $words = explode('_', $snakeCase);

        // Capitalize the first letter of each word and join them into a single string
        $camelCase = implode('', array_map('ucfirst', $words));

        // If capitalizeFirst is true, return the string as is, otherwise lowercase the first letter
        return $capitalizeFirst ? $camelCase : lcfirst($camelCase);
    }

    /**
     * Prepares request parameters by mapping the input array to a structured format.
     *
     * @param array $params The parameter definitions, expected to have a getName() and getType() method.
     * @param array|null $requestParameters The raw request data to map.
     * @return array The prepared request parameters.
     * @throws ReflectionException
     */
    private static function prepareRequestParams(array $params, ?array $requestParameters): array
    {
        $requestParams = [];

        foreach ($params as $param) {
            $paramName = $param->getName();

            // Handle special case for 'payload' parameter.
            if (
                $paramName === 'payload'
                || $paramName === 'body'
                || $paramName === 'requests'
                || $paramName === 'get_featured_offer_expected_price_batch_request_body'
            ) {
                $typeName = $param->getType()->getName();
                if (class_exists($typeName)) {
                    $requestInstance = new $typeName();
                    if (isset($requestParameters['body']['value'])) {
                        self::mapAttributes($requestInstance, $requestParameters['body']['value']);
                    } elseif (!$param->isOptional()) {
                        // Insert Dummy object
                        $openAPITypes = $typeName::openAPITypes();
                        $setters = $typeName::setters();

                        foreach ($openAPITypes as $propertyName => $propertyType) {
                            // Skip if the property is nullable
                            if ($typeName::isNullable($propertyName)) {
                                continue;
                            }

                            // Generate dummy value based on the type
                            $dummyValue = self::getDummyValueForType($propertyType, $propertyName);

                            // Check if a setter exists for the property
                            if (array_key_exists($propertyName, $setters)) {
                                $setterMethod = $setters[$propertyName];
                                if (method_exists($requestInstance, $setterMethod)) {
                                    // Call the setter method with the dummy value
                                    $requestInstance->$setterMethod($dummyValue);
                                }
                            }
                        }
                    }

                    $requestParams['payload'] = $requestInstance;
                } elseif ($typeName === 'array') {
                    $requestParams['payload'] = $requestParameters['body']['value'];
                }
                continue;
            }

            // Process regular parameters with snake_case to camelCase conversion.
            $value = null;
            foreach ([false, true] as $capitalizeFirst) {
                $camelCaseName = self::snakeToCamelCase($paramName, $capitalizeFirst);
                if (isset($requestParameters[$camelCaseName])) {
                    $subArray = $requestParameters[$camelCaseName];
                    if (is_array($subArray) && isset($subArray['value'])) {
                        $value = $subArray['value'];
                        break;
                    }
                }
            }
            if (empty($value) && !$param->isOptional()) {
                $typeName = $param->getType()->getName();
                // Insert Dummy parameter
                $value = self::getDummyValueForType($typeName, $paramName);
            }
            $requestParams[$paramName] = $value;
        }

        return $requestParams;
    }

    private static function generateUuidV4(): string
    {
        $data = openssl_random_pseudo_bytes(16);

        $data[6] = chr(ord($data[6]) & 0x0f | 0x40);
        $data[8] = chr(ord($data[8]) & 0x3f | 0x80);

        return vsprintf('%s%s-%s-%s-%s-%s%s%s', str_split(bin2hex($data), 4));
    }


    /**
     * Map for Domain Specific parameters
     * @var array
     */
    private static array $domainSpecificParameterMap = [
        'arn' => 'arn:aws:sqs:test:test:test',
        'notification_type' => 'ANY_OFFER_CHANGED',
        'event_filter_type' => 'ANY_OFFER_CHANGED',
        'offer_type' => 'CONSUMER',
        'expiration' => '2024-01-01',
        'country_code' => 'US',
        'op' => 'add',
        'requirements' => 'LISTING_OFFER_ONLY',
        'attributes' => [],
        // FbaInventory
        'granularity_type' => 'Marketplace',
        'quantity' => 0,
        'seller_sku' => 'automation_test'
    ];

    /**
     * Returns a dummy value based on the given type.
     *
     * @param string $typeName
     * @param string $paramName
     * @return mixed
     * @throws ReflectionException
     */
    private static function getDummyValueForType(string $typeName, string $paramName): mixed
    {
        // Handle domain specific case
        if (isset(self::$domainSpecificParameterMap[$paramName])) {
            return self::$domainSpecificParameterMap[$paramName];
        // Listing
        } elseif ($paramName === 'marketplace_ids') {
            return [$_ENV['SP_API_MARKETPLACE'] ?: self::$marketPlaceId];
        // FbaInventory
        } elseif ($paramName === 'marketplace_id') {
            return $_ENV['SP_API_MARKETPLACE'] ?: self::$marketPlaceId;
        } elseif ($paramName === 'x_amzn_idempotency_token') {
            return self::generateUuidV4();
        } elseif ($paramName === 'granularity_id') {
            return $_ENV['SP_API_MARKETPLACE'] ?: self::$marketPlaceId;
        }
        // Handle array and specific object types
        if (str_ends_with($typeName, '[]')) {
            $elementType = substr($typeName, 0, -2);
            return [self::getDummyValueForType($elementType, $paramName)];
        }

        if (class_exists($typeName)) {
            $reflectionClass = new ReflectionClass($typeName);
            $instance = $reflectionClass->newInstance();
            // Enum
            if (method_exists($instance, 'getAllowableEnumValues')) {
                $allowableValues = $instance::getAllowableEnumValues();
                return reset($allowableValues);
            }
            // Populate object properties recursively
            $openAPITypes = $instance::openAPITypes();
            $setters = $typeName::setters();

            foreach ($openAPITypes as $propertyName => $propertyType) {
                // Skip if the property is nullable
                if ($typeName::isNullable($propertyName)) {
                    continue;
                }

                // Generate dummy value based on the type
                $dummyValue = self::getDummyValueForType($propertyType, $propertyName);

                // Check if a setter exists for the property
                if (array_key_exists($propertyName, $setters)) {
                    $setterMethod = $setters[$propertyName];
                    if (method_exists($instance, $setterMethod)) {
                        // Call the setter method with the dummy value
                        $instance->$setterMethod($dummyValue);
                    }
                }
            }

            return $instance;
        }

        // Handle primitive types
        return match ($typeName) {
            'int' => 1,
            'float' => 1.0,
            'bool' => false,
            'string' => 'test',
            'array' => ["1"],
            default => null,
        };
    }

    /**
     * @param $apiInstance
     * @param string $methodName
     * @return ReflectionMethod
     * @throws ReflectionException
     */
    private static function getReflectionMethod($apiInstance, string $methodName): ReflectionMethod
    {
        return new ReflectionMethod($apiInstance, $methodName);
    }

    /**
     * Prepares the request parameters for a specified method of an API instance.
     *
     * This method uses reflection to retrieve the parameters of a given method
     * and matches them with the provided request array to prepare a structured
     * array of parameters for the method invocation.
     *
     * @param object $apiInstance The instance of the API class that contains the method.
     * @param string $methodName The name of the method for which parameters need to be prepared.
     * @param array $request An associative array of request parameters to be matched
     *                       with the method's defined parameters.
     *
     * @return array An array of parameters structured to match the specified method's signature.
     *
     * @throws ReflectionException If the reflection process fails, such as when the
     *                             specified method does not exist in the given API instance.
     */
    public static function prepareRequestParameter(object $apiInstance, string $methodName, ?array $request): array
    {
        $reflection = self::getReflectionMethod($apiInstance, $methodName);
        $params = $reflection->getParameters();
        return self::prepareRequestParams($params, $request);
    }

    /**
     * Extracts the request parameters and expected response from a JSON schema.
     *
     * This method processes a JSON schema string, decodes it, and extracts the
     * request parameters and expected response for a specified operation ID.
     * It prepares the request parameters to match the method signature of
     * the provided API instance.
     *
     * @param object $apiInstance The instance of the API class that contains the method to be invoked.
     * @param string $jsonSchema The JSON schema string representing the request and response definitions.
     * @param string $operationId The operation ID corresponding to the method in the API instance.
     *
     * @return array An associative array containing:
     *               - `requestParams` (array): Prepared request parameters for the specified method.
     *               - `expectedResponse` (mixed): The expected response extracted from the JSON schema.
     *
     * @throws \InvalidArgumentException If the provided JSON schema is invalid or cannot be decoded.
     * @throws ReflectionException If there is an error during the preparation of request parameters
     *                             (e.g., method does not exist in the API instance).
     */
    public function extractRequestAndResponse(object $apiInstance, string $jsonSchema, string $operationId): array
    {
        // Decode HTML entities
        $codegenText = html_entity_decode($jsonSchema);

        // Remove unnecessary characters
        $codegenText = str_replace(["\r", "\n"], '', $codegenText);
        //$codegenText = str_replace(' ', '', $codegenText);

        // Decode JSON
        $data = json_decode($codegenText, true);
        if (json_last_error() !== JSON_ERROR_NONE) {
            throw new \InvalidArgumentException("Invalid JSON schema provided: " . json_last_error_msg());
        }

        // Extract request object
        $request = $data['x-amzn-api-sandbox']['static'][0]['request']['parameters'] ?? null;

        // Prepare request parameters
        $requestParams = self::prepareRequestParameter(
            $apiInstance,
            $operationId,
            $request
        );

        // Extract expected response
        $expectedResponse = $data['x-amzn-api-sandbox']['static'][0]['response'] ?? null;

        return [
            'requestParams' => $requestParams,
            'expectedResponse' => $expectedResponse
        ];
    }

    /**
     * @throws ReflectionException
     */
    public function buildRequestForDynamicSandBox(object $apiInstance, string $operationId): array
    {
        // Prepare request parameters
        return self::prepareRequestParameter(
            $apiInstance,
            $operationId,
            null
        );
    }

    /**
     * Array that defines TestCase Name requires specific ateTimeFormat
     * @var array
     */
    private array $dateTimeFormatSpecificCase = [
        'FeesApi' => 'D M d H:i:s T Y',
        'ListingsItemsApi' => 'Y-m-d\TH:i:s\Z'
    ];


    /**
     * Get required DateTimeFormat for a given testCaseName.
     *
     * @param string $caseName
     * @return string|null
     */
    public function getDateTimeFormatForCase(string $caseName): ?string
    {
        return $this->dateTimeFormatSpecificCase[$caseName] ?? null;
    }

    /**
     * Array that defines scopes parameter required for grantless operation such as Notification API
     * @var array|string[]
     */
    private array $scopesRequiredMap = [
        'testCreateDestination200' => ['sellingpartnerapi::notifications'],
        'testGetDestination200' => ['sellingpartnerapi::notifications'],
        'testDeleteDestination200' => ['sellingpartnerapi::notifications'],
        'testGetDestinations200' => ['sellingpartnerapi::notifications'],
        'testDeleteSubscriptionById200' => ['sellingpartnerapi::notifications'],
        'testGetSubscriptionById200' => ['sellingpartnerapi::notifications'],
    ];


    /**
     * Get required scopes for a given caseName.
     *
     * @param string $caseName
     * @return array
     */
    public function getScopesForApi(string $caseName): array
    {
        return $this->scopesRequiredMap[$caseName] ?? [];
    }

    /**
     * Checks if the test case should be skipped.
     *
     * @param string $testCaseName
     * @param string|null $className
     * @return bool
     */
    public static function shouldSkipTest(string $testCaseName, ?string $className = null): bool
    {
        if (!in_array($testCaseName, TestHelper::$testSkipCasesList)) {
            return in_array($className, TestHelper::$testSkipCasesList);
        }
        return true;
    }

    /**
     * Array that defines test cases which are shippable for now
     * @var array|string[]
     */
    public static array $testSkipCasesList = [
        // Definition of Test Class which has not been tested
        'DefaultApi',
        'AplusContentApi',
        'AppIntegrationsApi',
        'ApplicationsApi',
        'AwdApi',
        'CustomerInvoicesApi',
        'EasyShipApi',
        'FbaOutboundApi',
        'InvoicesApi',
        'MessagingApi',
        'OffersApi',
        'QueriesApi',
        'SalesApi',
        'SellersApi',
        'SellingpartnersApi',
        'ServiceApi',
        'ShipmentInvoiceApi',
        'ShippingApi',
        'SolicitationsApi',
        'SupplySourcesApi',
        'TokensApi',
        'UpdateInventoryApi',
        'UploadsApi',
        'VendorInvoiceApi',
        'VendorOrdersApi',
        'VendorShipmentsApi',
        'VendorShippingApi',
        'VendorShippingLabelsApi',
        'VendorTransactionApi',

        // Definition of individual case which is unable to test
        // Order API
        // Missing required parameter in Request regulatedOrderVerificationStatus and can not be auto filled
        //Because there is no difference between 200 case.
        'testUpdateVerificationStatus400',
        'testGetOrderRegulatedInfo200', // Getting 403 due to restricted role required
        'testGetOrderRegulatedInfo400',  // Getting 403 due to restricted role required
        'testGetOrderItemsBuyerInfo200', // Response should have required field OrderItemId, but it doesn't
        // NotificationAPI
        'testDeleteSubscriptionById200', // Getting 400 with InvalidInput error
        'testGetSubscriptionById200', // Getting 400 with InvalidInput error
        // Feed API
        'testCancelFeed200', // Always 500 will be returned
        'testCreateFeed400', // Request should have mandatory field FeedType
        'testCreateFeedDocument400', // Request should have mandatory field ContentType
        // Report API
        'testCancelReport200',  // Always 500 will be returned
        'testCancelReportSchedule200', // Always 500 will be returned
        'testCreateReportSchedule400', // Request should have mandatory field MarketplaceIds
        // Pricing API
        'testGetCompetitiveSummary200', // Request offerType should be CONSUMER, not Consumer
        // FBA Inbound Eligibility API
        'testGetItemEligibilityPreview401', // Always 500 will be returned
        'testGetItemEligibilityPreview503', // Always 500 will be returned
        // fulfillmentInbound_2024-03-20
        'testGenerateShipmentContentUpdatePreviews202', // Sandbox Returns 400
        'testGenerateTransportationOptions202', // Sandbox Returns 400
        'testGetInboundPlan200', // Json expected Response of timestamp is in wrong format. Millisecond should be added.
        'testGetShipment200', // Json expected Response of timestamp is in wrong format. Millisecond should be added.
        // Json expected Response of timestamp is in wrong format. Millisecond should be added.
        'testScheduleSelfShipAppointment200',
        'testGetShipmentContentUpdatePreview200', // "expiration" at the Json expected Response Json is wrong
        'testListShipmentContentUpdatePreviews200', // "expiration" at the Json expected Response Json is wrong
        'testListInboundPlans200', //Json expected Response of timestamp is in wrong format.Millisecond should be added.
        'testListPrepDetails200', // Sandbox Returns 400
        'testSetPackingInformation202', // Sandbox Returns 400
        'testUpdateItemComplianceDetails202',  // Sandbox Returns 400
        'testSetPrepDetails202', // Sandbox Returns 400
        // CatalogItem
        'testGetCatalogItem200', // Response has Invalid value for images.variant such as PT09-PT14, EEGL and EGUS
        'testSearchCatalogItems200', // Response has Invalid value for images.variant such as PT09-PT14, EEGL and EGUS
        // ProductFeesAPI
        'testGetMyFeesEstimates200', // Sandbox Returns 400
        'testGetMyFeesEstimateForASIN400', // Request can not be made because Request is missing mandatory parameters
        'testGetMyFeesEstimateForSKU400', // Request can not be made because Request is missing mandatory parameters
        // ListingsItems_2021-08-01
        // Expected response is different from actual response.
        // TimeStamp Format is inconsistent within same Expected response Json
        'testGetListingsItem200',
        // fbaInventory
        'testAddInventory200', // Create inventory is dependency for this operation
        // listingsRestrictions
        'testGetListingsRestrictions400', // Error response can not be handled due to wrong ErrorList definition in Json
        // merchantFulfillment
        'testCancelShipment200', // Label.FileContents.FileType is Enum, but “” is returned.
        // ShippingService.ShippingServiceOptions.CarrierWillPickUp is mandatory, but not returned.
        'testCreateShipment200',
        //Response ShippingServiceList.ShippingServiceOptions.LabelFormat should be Enum value or removed
        'testGetEligibleShipmentServices200'
    ];
}
